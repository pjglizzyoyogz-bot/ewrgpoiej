-- Brainrot Detection and Discord Webhook Script (Client-side) with Enhanced Server Hopping
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- HTTP request function (compatible with most executors)
local request = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request
if not request then
    error("No HTTP request function found! Make sure you're using a compatible executor.")
end

-- Discord Webhook URLs
local webhooks = {
    highValue = "https://discord.com/api/webhooks/1420571524515102731/nhtroygawwGSM2U6ZmH2fBM8s2dtAfa3kEDRR1Q7x7bTfCqrLcXh2WjCuDubxOYDxgeS", -- 10M/s to 100M/s
    secretLowValue = "https://discord.com/api/webhooks/1420571944901939320/_4eendPWSlqgeNThqRlAQG5JrOcntU3rimQ3OMfQHwOTFMDrSeE6AZInEGpOto6hAOmc", -- Secret rarity < 1M/s
    mediumValue = "https://discord.com/api/webhooks/1420572218743853076/mn436Nx8jA2kclSJgT25JzQgImM8DV0EG6OaPprHxRqubkZAMynHXIvOdytdDLcuXOgq" -- 1M/s to 10M/s
}

-- Color palette for rotating embed colors
local colors = {
    0x00ff00, -- Green
    0xff6b35, -- Orange
    0x9b59b6, -- Purple
    0x3498db, -- Blue
    0xe74c3c, -- Red
    0xf1c40f, -- Yellow
    0x1abc9c, -- Teal
    0xe67e22  -- Dark Orange
}

-- Storage for detected brainrots by category
local detectedBrainrots = {
    highValue = {},
    secretLowValue = {},
    mediumValue = {}
}

-- Function to parse price string and convert to numerical value
local function parsePrice(priceStr)
    if not priceStr then return 0 end
    
    -- Remove $ and /s at the end
    local cleanPrice = priceStr:gsub("^%$", ""):gsub("/s$", "")
    local multiplier = 1
    
    if cleanPrice:find("K$") then
        multiplier = 1000
        cleanPrice = cleanPrice:gsub("K$", "")
    elseif cleanPrice:find("M$") then
        multiplier = 1000000
        cleanPrice = cleanPrice:gsub("M$", "")
    elseif cleanPrice:find("B$") then
        multiplier = 1000000000
        cleanPrice = cleanPrice:gsub("B$", "")
    end
    
    local numValue = tonumber(cleanPrice)
    return numValue and (numValue * multiplier) or 0
end

-- Function to get random color from palette
local function getRandomColor()
    return colors[math.random(1, #colors)]
end

-- Function to get player count (excluding local player)
local function getPlayerCount()
    local count = 0
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            count = count + 1
        end
    end
    return count
end

-- Function to get max server size
local function getMaxPlayers()
    return Players.MaxPlayers or 50 -- Default to 50 if not available
end

-- Function to send category embed with all brainrots
local function sendCategoryEmbed(webhookUrl, category, brainrots)
    if #brainrots == 0 then return end
    
    print("Sending " .. category .. " embed with " .. #brainrots .. " brainrots...")
    
    local jobId = game.JobId
    local joinScript = string.format('game:GetService("TeleportService"):TeleportToPlaceInstance(109983668079237, "%s", game.Players.LocalPlayer)', jobId)
    local playerCount = getPlayerCount()
    local maxPlayers = getMaxPlayers()
    local totalPlayers = #Players:GetPlayers()
    
    -- Create title based on category
    local titles = {
        highValue = "🧠 BRAINROTS DETECTED (" .. #brainrots .. " Found)",
        secretLowValue = "🧠 SECRET BRAINROTS DETECTED (" .. #brainrots .. " Found)",
        mediumValue = "🧠 BRAINROTS DETECTED (" .. #brainrots .. " Found)"
    }
    
    local fields = {}
    
    -- Add detected brainrots section
    table.insert(fields, {
        name = "DETECTED BRAINROTS",
        value = "",
        inline = false
    })
    
    -- Sort brainrots by value (highest first)
    table.sort(brainrots, function(a, b)
        return a.value > b.value
    end)
    
    -- Add each brainrot
    for i, brainrot in ipairs(brainrots) do
        local rarityEmoji = brainrot.rarity == "Secret" and "💎" or 
                           brainrot.rarity == "Legendary" and "🔥" or 
                           brainrot.rarity == "Epic" and "⚡" or "🔸"
        
        -- Format name with or without mutation
        local nameDisplay = brainrot.mutation == "Gold" and 
                           string.format("**%s**", brainrot.displayName) or 
                           string.format("**%s (%s)**", brainrot.displayName, brainrot.mutation)
        
        local petInfo = string.format("%s %s **%s** ➜ **%s**\nOwner: %s",
            rarityEmoji, nameDisplay, brainrot.generation, brainrot.rarity, brainrot.owner
        )
        
        table.insert(fields, {
            name = "",
            value = petInfo,
            inline = false
        })
    end
    
    -- Add Job ID sections
    table.insert(fields, {
        name = "💻 Job ID (PC)",
        value = jobId,
        inline = true
    })
    
    table.insert(fields, {
        name = "📱 Job ID (Mobile)",
        value = "```\n" .. jobId .. "\n```",
        inline = true
    })
    
    table.insert(fields, {
        name = "👥 Players in game:",
        value = "```\n" .. totalPlayers .. "/" .. maxPlayers .. "\n```",
        inline = true
    })
    
    -- Add Quick Join section
    local quickJoinUrl = string.format("https://fern.wtf/joiner?placeId=109983668079237&gameInstanceId=%s", jobId)
    table.insert(fields, {
        name = "🔗 Quick Join",
        value = "[Click to Join](" .. quickJoinUrl .. ")",
        inline = false
    })
    
    -- Add Join Script
    table.insert(fields, {
        name = "📜 Join Script",
        value = "```lua\n" .. joinScript .. "\n```",
        inline = false
    })
    
    local embed = {
        embeds = {{
            title = titles[category],
            color = getRandomColor(),
            fields = fields,
            footer = {
                text = "GFH Brainrot Logger Notifications 💩 | https://discord.gg/aVTyZq3hU4"
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
    }
    
    local data = HttpService:JSONEncode(embed)
    
    local success, response = pcall(function()
        return request({
            Url = webhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = data
        })
    end)
    
    if success then
        if response and response.Success then
            print("✅ Successfully sent " .. category .. " embed to Discord!")
        else
            warn("❌ Discord request failed: " .. (response and tostring(response.StatusCode) or "No response"))
            if response and response.Body then
                warn("Response body: " .. tostring(response.Body))
            end
        end
    else
        warn("❌ Error making request: " .. tostring(response))
    end
end

-- Function to get plot owner name
local function getPlotOwner(plot)
    local plotSign = plot:FindFirstChild("PlotSign")
    if plotSign then
        local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
        if surfaceGui then
            local frame = surfaceGui:FindFirstChild("Frame")
            if frame then
                local textLabel = frame:FindFirstChild("TextLabel")
                if textLabel then
                    local fullText = textLabel.Text
                    -- Extract name from "playername's Base" format and clean it
                    local ownerName = fullText:match("(.+)'s [Bb]ase")
                    return ownerName or "Unknown"
                end
            end
        end
    end
    return "Unknown"
end

-- Function to check and process animal data
local function checkAnimal(animalOverhead, plotId, podiumNumber, plot)
    if not animalOverhead then return end
    
    local displayName = animalOverhead:FindFirstChild("DisplayName")
    local mutation = animalOverhead:FindFirstChild("Mutation")
    local generationLabel = animalOverhead:FindFirstChild("Generation")
    local rarity = animalOverhead:FindFirstChild("Rarity")
    
    if not (displayName and mutation and generationLabel and rarity) then
        return
    end
    
    local displayNameText = displayName.Text
    local mutationText = mutation.Text
    local generationText = generationLabel.Text
    local rarityText = rarity.Text
    
    print("Found animal: " .. displayNameText .. " | Generation: " .. generationText .. " | Rarity: " .. rarityText)
    
    local priceValue = parsePrice(generationText)
    local ownerName = getPlotOwner(plot)
    
    -- Create brainrot data
    local brainrotData = {
        displayName = displayNameText,
        mutation = mutationText,
        generation = generationText,
        rarity = rarityText,
        plotId = plotId,
        value = priceValue,
        owner = ownerName
    }
    
    -- Check conditions and add to appropriate category
    if priceValue >= 10000000 and priceValue < 100000000 then -- 10M/s to 100M/s
        table.insert(detectedBrainrots.highValue, brainrotData)
        print("High value brainrot detected: " .. displayNameText .. " - " .. generationText)
    elseif rarityText == "Secret" and priceValue < 1000000 then -- Secret rarity less than 1M/s
        table.insert(detectedBrainrots.secretLowValue, brainrotData)
        print("Secret low value brainrot detected: " .. displayNameText .. " - " .. generationText)
    elseif priceValue >= 1000000 and priceValue < 10000000 then -- 1M/s to 10M/s
        table.insert(detectedBrainrots.mediumValue, brainrotData)
        print("Medium value brainrot detected: " .. displayNameText .. " - " .. generationText)
    end
end

-- Enhanced Server Hopping System
local Servers = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
local Server, Next = nil, nil

local function ListServers(cursor)
    local attempts = 0
    local maxAttempts = 3
    
    while attempts < maxAttempts do
        attempts = attempts + 1
        local success, result = pcall(function()
            local Raw = game:HttpGet(Servers .. ((cursor and "&cursor=" .. cursor) or ""))
            return HttpService:JSONDecode(Raw)
        end)
        
        if success then
            return result
        else
            warn("⚠️ Server list request failed (attempt " .. attempts .. "/" .. maxAttempts .. "): " .. tostring(result))
            if string.find(tostring(result):lower(), "429") or string.find(tostring(result):lower(), "too many") then
                print("🕐 Rate limited! Waiting 15 seconds before retry...")
                wait(15)
            else
                wait(3)
            end
        end
    end
    
    error("Failed to get server list after " .. maxAttempts .. " attempts")
end

-- Enhanced server hopping function
local function smartServerHop()
    print("🔍 Searching for available servers...")
    
    local success, result = pcall(function()
        local page = 1
        local maxPages = 50  -- Increased from 20 to search more thoroughly
        local serversChecked = 0
        local fullServers = 0
        
        while page <= maxPages do
            print("📋 Searching page " .. page .. "...")
            local serverData = ListServers(Next)
            
            if not serverData or not serverData.data or #serverData.data == 0 then
                print("📄 No more servers found on page " .. page)
                break
            end
            
            -- Check each server on this page
            for i, server in pairs(serverData.data) do
                serversChecked = serversChecked + 1
                
                -- Skip current server
                if server.id ~= game.JobId then
                    local availableSlots = server.maxPlayers - server.playing
                    
                    if availableSlots > 0 then
                        print("✅ Found available server: " .. server.id .. " (" .. server.playing .. "/" .. server.maxPlayers .. " players, " .. availableSlots .. " slots)")
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, Players.LocalPlayer)
                        return true
                    else
                        fullServers = fullServers + 1
                        if serversChecked % 10 == 0 then  -- Progress update every 10 servers
                            print("🔄 Progress: Checked " .. serversChecked .. " servers, " .. fullServers .. " full")
                        end
                    end
                end
            end
            
            -- Move to next page
            Next = serverData.nextPageCursor
            if not Next then
                print("📑 Reached end of server list after " .. page .. " pages")
                break
            end
            
            page = page + 1
            wait(0.5)  -- Reduced delay but still avoid rate limiting
        end
        
        print("⚠️ Search complete: Checked " .. serversChecked .. " servers, " .. fullServers .. " were full")
        
        -- If we get here, no available servers were found
        if fullServers > 0 then
            print("🎯 All servers appear to be full! Implementing fallback strategy...")
            return "all_full"
        else
            print("❌ No servers found at all")
            return false
        end
    end)
    
    if success then
        if result == true then
            print("🚀 Server hop initiated successfully!")
            return true
        elseif result == "all_full" then
            print("🔄 All servers full, implementing retry strategy...")
            return "retry"
        else
            print("❌ No suitable servers found")
            return false
        end
    else
        warn("💥 Server hop failed: " .. tostring(result or "Unknown error"))
        Next = nil
        return false
    end
end

-- Main function to scan all plots
local function scanAllPlots()
    local plots = workspace:FindFirstChild("Plots")
    if not plots then
        warn("Plots folder not found in workspace")
        return
    end
    
    print("Starting brainrot scan...")
    
    -- Clear previous results
    detectedBrainrots.highValue = {}
    detectedBrainrots.secretLowValue = {}
    detectedBrainrots.mediumValue = {}
    
    for _, plot in pairs(plots:GetChildren()) do
        if plot:IsA("Model") then
            local plotId = plot.Name
            print("Scanning plot: " .. plotId)
            
            local animalPodiums = plot:FindFirstChild("AnimalPodiums")
            if animalPodiums then
                -- Find the highest numbered podium (up to 28)
                for i = 1, 28 do
                    local podium = animalPodiums:FindFirstChild(tostring(i))
                    if podium then
                        local base = podium:FindFirstChild("Base")
                        if base then
                            local spawn = base:FindFirstChild("Spawn")
                            if spawn then
                                local attachment = spawn:FindFirstChild("Attachment")
                                if attachment then
                                    local animalOverhead = attachment:FindFirstChild("AnimalOverhead")
                                    if animalOverhead then
                                        checkAnimal(animalOverhead, plotId, i, plot)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    print("Brainrot scan completed!")
end

-- Enhanced continuous scanner with better full server handling
local function continuousScanner()
    local consecutiveFullServerAttempts = 0
    local maxConsecutiveAttempts = 3
    
    while true do
        local success, error = pcall(scanAllPlots)
        if not success then
            warn("💥 Error during scan: " .. tostring(error))
            print("⏳ Retrying in 5 seconds...")
            wait(5)
        else
            print("✅ Scan completed successfully!")
        end
        
        -- Check if any brainrots were found
        local totalFound = #detectedBrainrots.highValue + #detectedBrainrots.secretLowValue + #detectedBrainrots.mediumValue
        
        if totalFound > 0 then
            -- Send embeds
            print("📤 Sending Discord embeds...")
            sendCategoryEmbed(webhooks.highValue, "highValue", detectedBrainrots.highValue)
            wait(1)
            sendCategoryEmbed(webhooks.secretLowValue, "secretLowValue", detectedBrainrots.secretLowValue)
            wait(1)
            sendCategoryEmbed(webhooks.mediumValue, "mediumValue", detectedBrainrots.mediumValue)
            print("📬 All embeds sent!")
            print("🎉 Found " .. totalFound .. " brainrots! Server hopping...")
            wait(3)
        else
            print("🔍 No brainrots found, server hopping...")
            wait(2)
        end
        
        -- Queue script for auto-execution
        queue_on_teleport([[

        
        -- Attempt server hop with enhanced handling
        local hopResult = smartServerHop()
        
        if hopResult == true then
            print("🎯 Successfully hopping to new server!")
            consecutiveFullServerAttempts = 0
            break  -- Exit loop since we're teleporting
        elseif hopResult == "retry" then
            consecutiveFullServerAttempts = consecutiveFullServerAttempts + 1
            print("🔄 Attempt " .. consecutiveFullServerAttempts .. "/" .. maxConsecutiveAttempts .. " - All servers full")
            
            if consecutiveFullServerAttempts >= maxConsecutiveAttempts then
                print("⏰ All servers consistently full. Waiting longer before retry...")
                print("🎮 Game has " .. (#Players:GetPlayers()) .. " players - very popular right now!")
                
                -- Progressive wait times when servers are consistently full
                local waitTime = math.min(30 + (consecutiveFullServerAttempts * 10), 120)  -- Max 2 minutes
                print("⌛ Waiting " .. waitTime .. " seconds for servers to free up...")
                wait(waitTime)
                
                -- Reset counter after long wait
                if consecutiveFullServerAttempts >= 5 then
                    consecutiveFullServerAttempts = 0
                    print("🔄 Resetting search parameters...")
                    Server, Next = nil, nil
                end
            else
                print("⏳ Short wait before retry...")
                wait(10 + math.random(5, 15))  -- Random delay to avoid synchronized attempts
            end
        else
            consecutiveFullServerAttempts = 0
            print("⚠️ Server hop failed, continuing scan in current server...")
            print("⏳ Waiting 10 seconds before next scan...")
            wait(10)
        end
        
        -- Reset server variables for fresh search
        Server, Next = nil, nil
    end
end

-- Run the continuous scanner
continuousScanner()
